[Оригинал](https://roadmap.sh/software-design-architecture)

Полезные ссылки:

* [How to Learn Software Design and Architecture | The Full-stack Software Design & Architecture Map](https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/)

# Основные принципы проектирования программного обеспечения и виды архитектур приложений

## Принципы проектирования, базирующиеся на понятии «чистого кода»

Чистый код — это код, который легко читать, понимать и поддерживать. Он следует набору принципов, призванных сделать код более читабельным, тестируемым и менее подверженным ошибкам. Вот некоторые из ключевых принципов чистого кода:

* Ясность: код должен быть легко читаемым и понятным.
* Простота: код должен быть максимально простым, избегающим ненужной сложности.
* Комментарии. Комментарии следует использовать с осторожностью и только в случае необходимости для объяснения сложного или неочевидного кода.
* Именование: переменные, функции и классы должны иметь осмысленные и содержательные имена.
* Форматирование: код должен быть последовательно отформатирован для повышения читабельности.
* Функциональность: код должен быть организован в виде небольших функций и классов, выполняющих какую-то одну специализированную задачу.
* Обработка ошибок: код должен обрабатывать ошибки последовательным и предсказуемым образом.
* Тестирование: код должен быть тестируемым и иметь высокое покрытие тестами.
* Повторное использование: код должен быть многократно используемым и модульным.
* Производительность: код должен быть эффективным и производительным.

Полезные ссылки:

* [Introduction to Clean Code & Software Design Principles](https://workat.tech/machine-coding/tutorial/introduction-clean-code-software-design-principles-nwu4qqc63e09)

### Будьте последовательны при написании кода

Быть последовательным означает использовать одну и ту же однотипную манеру при написании кода. Она может включать использование принятых соглашений об именах, структур данных и интерфейсов во всей системе, а также соблюдение установленных в команде принципов проектирования и лучших практик. Такая последовательность поможет сделать систему более удобной в сопровождении, понятной и расширяемой.

Полезные ссылки:

* [10 Tips for Writing Clean Code](https://www.pluralsight.com/blog/software-development/10-steps-to-clean-code)

### Содержательные, понятные названия переменных, не требующие дополнительных комментариев

Вы должны придерживаться практики давать четкие и содержительные имена различным компонентам системы, таким как переменные, функции и классы. Это поможет сделать систему более понятной и удобной в сопровождении за счет четкого указания назначения каждого компонента и его предполагаемого использования.

Использование осмысленных имен важно для того, чтобы сделать код понятным, читаемым и легким для понимания. Содержательные имена могут помочь передать назначение и функцию переменных, функций, классов и других элементов кода.

Ниже приведены некоторые примеры использования содержительных имен в системной архитектуре:

* Используйте описательные и осмысленные имена для переменных, функций, классов и других элементов кода.
* Используйте принятые командой соглашения об именах во всей кодовой базе, такие как camelCase для переменных и PascalCase для функций и классов.
* Используйте аббревиатуры и акронимы с осторожностью и только в том случае, если они понятны всем членам команды.
* Используйте осмысленные префиксы или суффиксы для указания типа или назначения переменной или функции, например «is» или «get» для логических переменных или «list» для переменных-массивов.
* Избегайте использования однобуквенных имён переменных или ничем не примечательных имён, таких как «temp» или «x», которые не несут никакой смысловой нагрузки.
* Избегайте использования слишком длинных или сложных имен, которые затрудняют чтение кода.

Полезные ссылки:

* [A Guide for Naming Things in Programming](https://levelup.gitconnected.com/a-guide-for-naming-things-in-programming-2dc2d74879f8)
* [How to Write Meaningful Variable Names?](https://workat.tech/machine-coding/tutorial/writing-meaningful-variable-names-clean-code-za4m83tiesy0)

### Стиль программирования: отступы

Использование отступов позволяет на практике визуально сгруппировать связанные строки кода вместе, что облегчает чтение и понимание структуры кода. Выбор того или иного количества пробелов для отступа относится к соглашениям и рекомендациям, принятым внутри команды, которые используются для форматирования и структурирования кода, по аналогии с соглашениями об именах, комментариях и использовании пробелов.

Наличие единого стиля поможет сделать код более читаемым и понятным, что может повысить удобство сопровождения системы.

Полезные ссылки:

* [Clean Code – Formatting](https://www.baeldung.com/cs/clean-code-formatting)

### Старайтесь, чтобы создаваемые методы, классы, файлы, были как можно меньше

Старайтесь проектировать и создавать небольшие специализированные компоненты, которые решают определенную задачу, а не большие монолитные компоненты, которые пытаются сделать всё сразу. Это поможет улучшить удобство сопровождения и масштабируемость системы, облегчая понимание, тестирование и модификацию отдельных компонентов.

### Используйте чистые функции

Чистая функция — это функция определенного типа, удовлетворяющая следующим критериям:

* Она принимает некоторые входные данные, называемые аргументами, и возвращает значение или выходные данные.
* Она не приводит к каким-либо наблюдаемым побочным эффектам, таких как изменение состояния системы или взаимодействие с внешними ресурсами.
* При одних и тех же входных данных она всегда будет возвращать один и тот же результат.
* Она не зависит ни от какого состояния или переменных, которые находятся за пределами её области видимости.

Чистые функции считаются более предсказуемыми и их легче тестировать, поскольку их поведение определяется исключительно поступающими на вход данными и их внутренней логикой. Они также облегчают анализ поведения программы, поскольку на результат чистой функции не влияют никакие внешние факторы. Чистые функции часто используются в функциональном программировании, где они считаются важнейшим принципом. Их также используют в конкурентном и параллельном программировании, поскольку они менее подвержены эффектам гонки данных и другим проблемам, связанным с параллелизмом.

[Википедия - Чистота функции](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)

### Минимизируйте цикломатическую сложность программы

Цикломатическая сложность — это мера структурной сложности программы, которая определяется количеством линейно независимых путей в порядке выполнения программы. Высокая цикломатическая сложность может затруднить понимание, тестирование и сопровождение программы, поэтому часто желательно свести ее к минимуму в архитектуре системы.

Ниже показано несколько способов минимизировать цикломатическую сложность в архитектуре системы:

* Разбейте сложные функции на более мелкие и простые функции, выполняющие определенные задачи.
* Используйте управляющие конструкции, такие как операторы if-else и циклы, согласованным и предсказуемым образом.
* Используйте понятия и методы функционального программирования, такие как неизменяемость и чистые функции, чтобы уменьшить потребность в сложном порядке выполнения.
* Используйте шаблоны проектирования, такие как шаблон состояния, для упрощения сложного порядка выполнения.
* Регулярно просматривайте код и реорганизуйте его, чтобы упростить порядок выполнения.
* Используйте инструменты статического анализа кода, которые могут обнаруживать и сообщать о высокой цикломатической сложности кода.

Следуя этим рекомендациям, архитектура системы будет более удобной в сопровождении, тестируемой и менее подверженной ошибкам.

Полезные ссылки:

* [How to reduce cyclomatic complexity?](https://kasp9023.medium.com/how-to-make-your-code-more-readable-focus-on-the-happy-path-and-reduce-cyclomatic-complexity-66802b8897b5)
* [Википедия - Цикломатическая сложность](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

### Старайтесь не передавать значения типа null и булевого типа

Передача значения типа `null` или булевых (логических) значений может привести к неожиданному поведению и трудным для отладки ошибкам в программе. Вот несколько способов избежать передачи значения типа `null` или булевых значений в архитектуре системы:

* Используйте типы `Optionals` или `Maybe` вместо `null`, чтобы указать на отсутствие значения. Это позволяет понять, когда значение отсутствует, и предотвращает возникновение исключений, связанных с тем, что указатель ссылается на `null`.
* Используйте значение по умолчанию для аргументов функции вместо того, чтобы позволять им быть равными `null` или значениям логического типа. Это устраняет необходимость проверки  на `null` или значения логического типа и снижает вероятность ошибок.
* Используйте шаблон `Null Object` для замены значений типа `null` специальным объектом с определенным поведением. Это устраняет необходимость проверки на `null` и делает код более читабельным.
* Используйте тернарный оператор (?:) вместо операторов if-else при работе с логическими значениями. Это может сделать код более компактным и удобным для чтения.
* Используйте функцию `assert`, чтобы проверить допустимость аргументов функции и создать исключение, если они не удовлетворяют требованиям.

Следуя этим рекомендациям, архитектура системы будет более надежной и менее подверженной ошибкам.

### Следите за тем, что код фреймворка был дистанцирован

Дистанцирование кода фреймворка означает отделение кода приложения от кода фреймворка. Это упрощает независимое обслуживание, тестирование и обновление кодовой базы приложения и фреймворка.

Вот несколько способов, позволяющих отделить код фреймворка от архитектуры системы:

1. Используйте уровень абстракции, чтобы отделить код приложения от кода фреймворка. Это позволяет писать код приложения без необходимости знать специфику фреймворка.
2. Используйте внедрение зависимостей, чтобы отделить код приложения от кода фреймворка. Это позволяет коду приложения использовать функциональные возможности фреймворка без необходимости непосредственного создания экземпляров объектов фреймворка.
3. Избегайте использования специфичных для фреймворка библиотек или классов в коде приложения. Это упрощает переход на другой фреймворк в будущем, если это будет необходимо.
4. Используйте стандартный интерфейс кода приложения для взаимодействия с фреймворком. Это позволяет писать код приложения без необходимости знать специфику фреймворка.
5. Располагайте приложение и код фреймворка в отдельных проектах и/или репозиториях.

Следуя этим рекомендациям, архитектура системы будет более удобной в сопровождении, тестируемой и менее подверженной ошибкам, а также будет проще обновлять или переходить на другой фреймворк в случае необходимости.

Полезные ссылки:

* [Clean architecture](https://pusher.com/tutorials/clean-architecture-introduction/)

### Используйте составляющие части вашей программы с умом

### Тесты должны выполняться быстро и быть независимыми

Полезные ссылки:

* [Keeping Tests Valuable](https://www.checklyhq.com/learn/headless/valuable-tests/)

### Группируйте код вокруг а́ктора, к которому он относится

Полезные ссылки:

* [Actor Model Architecture](https://awesome-architecture.com/actor-model-architecture/actor-model-architecture/)

### Разделяйте на команды и запросы

Полезные ссылки:

* [CQRS Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)

### Избегайте ненужной сложности и осуществляйте рефакторинг как можно чаще

Полезные ссылки:

* [AHA Programming](https://kentcdodds.com/blog/aha-programming)

## Парадигмы программирования

Парадигма программирования — это фундаментальный стиль или подход к решению проблем с использованием языка программирования. Различные парадигмы программирования предоставляют разные способы организации и структурирования кода и имеют разные сильные и слабые стороны. Некоторые из наиболее распространенных парадигм программирования включают в себя:

* Императивное программирование
* Функциональное программирование
* Объектно-ориентированное программирование
* Логическое программирование
* Декларативное программирование

Полезные ссылки:

* [Overview of Programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm)
* [Introduction of Programming Paradigms](https://www.geeksforgeeks.org/introduction-of-programming-paradigms/)
* [Википедия - Парадигма программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

### Структурное программирование

Структурное программирование — это парадигма программирования, которая делает упор на использование структурированных управляющих конструкций, изменющих ход выполнения программы, таких как циклы и условные операторы, для организации кода в логические, простые для понимания блоки. Это способ написания компьютерных программ, в котором особое внимание уделяется использованию процедур и функций, а также структур данных для организации кода и упрощения его понимания, отладки и поддержки. Основная идея структурного программирования состоит в том, чтобы разбить программу на более мелкие части, которые просто контролировать, можно легко понять, протестировать и изменить. Этот подход выступает против использования операторов «goto», которые считаются неструктурированными и могут привести к сложному для чтения и сопровождения коду.

Полезные ссылки:

* [Overview of Structured programming](https://www.techtarget.com/searchsoftwarequality/definition/structured-programming-modular-programming)

### Функциональное программирование

Функциональное программирование — это парадигма программирования, которая делает упор на использование чистых функций и неизменяемых данных. Это способ написания компьютерных программ, который  акцентирует внимание на использовании функций и математических понятий, таких как рекурсия, а не на использование объектов и классов, как в объектно-ориентированном программировании. В функциональном программировании функции являются «объектами первого класса» (функции высших порядков), что означает, что они могут быть переданы в качестве аргументов другим функциям и возвращены в качестве результата.

Функциональное программирование поощряет неизменяемость, что означает, что после того, как переменной присвоено значение, его нельзя изменить. Это может упростить код, так как устраняет необходимость управления состоянием и ошибок, которые могут возникнуть при этом.

Полезные ссылки:

* [What is Functional Programming?](https://www.codingdojo.com/blog/what-is-functional-programming)
* [Tutorial - Functional Programming?](https://www.youtube.com/watch?v=dAPL7MQGjyM)

### Объектно-ориентированное программирование

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на понятии «объектов», которые являются экземплярами классов. ООП — это способ организации и структурирования кода, основанный на принципах инкапсуляции, наследования и полиморфизма.

Инкапсуляция — это идея, заключающаяся в том, что внутреннее состояние объекта должно быть скрыто и доступно только через его методы. Это позволяет объекту контролировать, как используются его данные, и не позволяет внешнему коду вносить недопустимые изменения в состояние объекта.

В ООП класс — это шаблон для создания объектов, которые имеют как данные (атрибуты), так и поведение (методы). Основная идея ООП заключается в моделировании объектов реального мира и их взаимодействий, что делает его подходящим для создания сложных и крупномасштабных программных систем.

Полезные ссылки:

* [What is Object Oriented Programming?](https://www.youtube.com/watch?v=pTB0EiLXUC8)
* [Overview of Object-Oriented Programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming)
* [Википедия - Объектно-ориентированное программирование](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
* [Discover Object Oriented Programming](https://blog.hubspot.com/website/object-oriented-programming)
* [Software Development Tutorial - What is object-oriented language?](https://www.youtube.com/watch?v=SS-9y0H3Si8)

#### Модельно-ориентированный подход к проектированию

Модельно-ориентированный подход к проектированию (MDD) — это методология разработки программного обеспечения, в которой проектирование системы осуществляется с помощью набора моделей, используемые для управления процессом разработки системы. MDD основан на идее, что конструкция системы может быть представлена набором моделей и что эти модели могут быть применены для генерации кода для системы.

Основное преимущество использования MDD заключается в том, что он позволяет четко разделить задачи проектирования и реализации системы. Модели представляют структуру системы, а код генерируется на основе моделей, что упрощает поддержку и развитие системы. Кроме того, MDD также может улучшить качество кода, поскольку модели можно использовать для проверки ошибок проектирования и несоответствий до создания кода.

Полезные ссылки:

* [Model Driven Design – theory to practice](https://www.todaysoftmag.com/article/1529/model-driven-design-theory-to-practice)

##### Модель предметной области

Модель предметной области — это воплощение конкретной области знаний или бизнеса, которое используется для моделирования объектов и понятий в этой предметной области, а также для определения взаимосвязей и ограничений между ними. В объектно-ориентированном программировании (ООП) модель предметной области обычно представлена набором классов и интерфейсов, где каждый класс или интерфейс представляет определенное понятие или объект в предметной области.

Модель предметной области используется для обеспечения четкого и последовательного представления предметной области, а также для отражения бизнес-требований и ограничений системы. Она также применяется в качестве ориентира при проектировании системы и для гарантирования того, чтобы система точно отражала реальную проблему, которую она призвана решать.

Полезные ссылки:

* [Overview of Domain model](https://en.wikipedia.org/wiki/Domain_model)
* [Domain Driven Design](https://khalilstemmler.com/articles/categories/domain-driven-design/)

##### Анемичная модель

Анемичная модель, также известная как анемичная модель предметной области, представляет собой тип модели предметной области, в которой объекты предметной области содержат только данные (атрибуты) и не имеют поведения. Анемичная модель часто приводит к использованию объектов переноса данных (DTO) и сервисного уровня для реализации поведения.

Анемичная модель считается антишаблоном в объектно-ориентированном программировании (ООП), потому что она нарушает принципы инкапсуляции и разделения ответственности. В анемичной модели поведение отделено от данных и обычно реализуется на отдельном сервисном уровне, что может привести к сложному, сильно связанному и сложному в сопровождении коду.

Полезные ссылки:

* [Overview of Anemic Domain Model](https://en.wikipedia.org/wiki/Anemic_domain_model)
* [What is an Anaemic Domain Model?](https://www.ensonodigital.com/blog/anaemic-domain-model-vs-rich-domain-model)

##### Многоуровневые архитектуры

Многоуровневая архитектура — это шаблон проектирования программного обеспечения, в котором функциональность системы разделена на набор уровней, при этом каждый уровень имеет определенную ответственность и взаимодействует с уровнями выше и ниже него. Основная идея многоуровневой архитектуры состоит в том, чтобы разделить задачи системы на отдельные и независимые уровни, сделав код более модульным, более простым для понимания, тестирования и модификации.

Существует несколько типов многоуровневых архитектур, но наиболее распространенной является трехуровневая архитектура, состоящая из:

* Уровень представления (Presentation Layer)
* Уровень бизнес-логики (Business Layer)
* Уровень доступа к данным (Data Access Layer)

Полезные ссылки:

* [Software Architecture Patterns — Layered Architecture](https://priyalwalpita.medium.com/software-architecture-patterns-layered-architecture-a3b89b71a057)
* [5 Primary Layers in Software Architecture?](https://www.indeed.com/career-advice/career-development/what-are-the-layers-in-software-architecture)

##### Единый язык

Единый язык — это специфический словарь и набор понятий, используемых для описания и общения в определенной области знаний или бизнеса. При разработке программного обеспечения единый язык язык используется для моделирования объектов и понятий в конкретной предметной области, а также для фиксации взаимосвязей и ограничений между ними.

Единый язык используется для обеспечения единообразного понимания проблемной области всеми заинтересованными сторонами, включая разработчиков, бизнес-аналитиков и экспертов в предметной области. Он также применяется, чтобы гарантировать, что программная система точно отражает существующую в реальном мире проблему, которую она призвана решать.

Полезные ссылки:

* [Overview of Domain-specific language](https://en.wikipedia.org/wiki/Domain-specific_language)
* [What are Domain Languages (DSLs)?](https://www.jetbrains.com/mps/concepts/domain-specific-languages/)

##### Инварианты класса

Инвариант класса — это набор условий, которые должны выполняться для любого объекта класса в любой момент времени. В объектно-ориентированном программировании (ООП) инварианты классов используются для определения допустимых состояний объекта и гарантирования того, чтобы объект всегда будет оставаться в допустимом состоянии.

Инварианты класса обычно определяются в конструкторе класса и задаются с помощью закрытых методов и атрибутов, которые используются для проверки состояния объекта. Они также проверяются в методах класса до и после любой операции, которая может изменить состояние объекта.

Полезные ссылки:

* [Overview of Class invariant](https://en.wikipedia.org/wiki/Class_invariant)
* [Википедия - Инвариант класса](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
* [The concept of class invariant in object-oriented programming](https://arxiv.org/abs/2109.06557)

#### Особенности парадигмы

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на понятии «объектов», которые являются экземплярами класса. ООП имеет несколько ключевых особенностей, которые отличают его от других парадигм программирования:

* Инкапсуляция
* Наследование
* Полиморфизм
* Абстракция
* Классы
* Объекты
* Интерфейсы
* Динамическое (позднее) связывание
* Передача сообщений

Полезные ссылки:

* [Overview of Object-Oriented Paradigm](https://www.tutorialspoint.com/software_architecture_design/object_oriented_paradigm.htm)

##### Абстрактные классы

Абстрактный класс — это класс в объектно-ориентированном программировании (ООП), который не может быть создан. Вместо этого он служит шаблоном или образцом для наследования другими классами. Абстрактный класс может содержать как абстрактные, так и неабстрактные методы (абстрактные методы — это методы, которые не имеют реализации, они просто содержат сигнатуру).

Абстрактные классы используются для предоставления общего интерфейса и реализации для группы связанных классов. Они также применяются для определения общего поведения, которое должно быть реализовано всеми подклассами. Подкласс, который наследуется от абстрактного класса, называется реальным классом, и он должен предоставлять реализацию для всех абстрактных методов, объявленных в родительском классе.

Полезные ссылки:

* [What is an Abstract Class in Object Oriented Programming](https://computinglearner.com/abstract-class-in-object-oriented-programming/)

##### Реальные классы

Реальный класс — это класс в объектно-ориентированном программировании (ООП), который может быть создан, то есть из него могут быть созданы объекты. Реальный класс — это класс, который обеспечивает реализацию всех абстрактных методов, объявленных в его родительском классе, если он наследуется от абстрактного класса. Реальный класс также может быть классом, который не наследуется от абстрактного класса, в этом случае в нём реализованы все его методы.

Реальные классы используются для предоставления конкретных деталей реализации для группы связанных классов, которые наследуются от общего абстрактного класса. Они также используются для задания уникального поведения для определенного класса. Реальный класс может иметь свои собственные методы и переменные, а также может переопределять методы своего родительского класса.

Полезные ссылки:

* [Concrete class in Java](https://www.geeksforgeeks.org/concrete-class-in-java/)

##### Область видимости

Область видимости относится к доступности или видимости переменных, функций и других элементов в программе в зависимости от контекста, в котором они определены. В объектно-ориентированном программировании (ООП) область видимости контролируется с помощью модификаторов доступа, таких как "public" («публичный», «открытый», «общедоступный»), "private" («приватный», «закрытый», «частный») и "protected" («защищённый»).

Общедоступный: к общедоступному элементу можно получить доступ из любой точки программы, как внутри класса, так и за его пределами.

Закрытый: доступ к закрытому элементу возможен только внутри класса, в котором он определен. Он недоступен для других классов, даже если они наследуются от класса.

Защищенный: доступ к защищенному элементу возможен только внутри класса и его подклассов.

Существуют и другие разновидности области видимости в зависимости от языка программирования, но эти являются наиболее распространенными.

Полезные ссылки:

* [Википедия — Область видимости](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8)

##### Интерфейсы

В объектно-ориентированном программировании (ООП) интерфейс — это контракт или набор методов, которые должен реализовать класс. Он определяет общий набор методов, которые должен иметь класс, но не предоставляет никаких подробностей реализации. Интерфейс может включать как сигнатуры методов, так и константы.

Интерфейсы используются для определения общего поведения для группы связанных классов и для обеспечения полиморфизма в случае с объектами разных классов. Класс, удовлетворяющий интерфейсу, должен осуществлять реализацию всех методов, объявленных в интерфейсе. Класс может реализовывать несколько интерфейсов, но может наследоваться только от одного базового класса.

Полезные ссылки:

* [Fundamental concepts: What’s an Interface?](https://www.youtube.com/watch?v=o1jBgdhQsGo)

#### Основные понятия

Существует несколько основных понятий, которые считаются фундаментальными для объектно-ориентированного программирования (ООП). Эти понятия включают в себя:

* Инкапсуляция: Практика помещения внутренних данных и поведения объекта в определенный интерфейс и сокрытие деталей реализации от внешнего мира.
* Наследование: способность нового класса наследовать свойства и методы существующего класса, что позволяет повторно использовать код и обеспечивает иерархическую организацию классов.
* Полиморфизм: способность рассматривать объекты разных классов как объекты общего родительского класса, что позволяет писать более обобщённый и универсальный код.
* Абстракция: процесс сокрытия деталей реализации объекта и раскрытия только его основных функций, что снижает сложность и улучшает модульность кода.
* Классы: шаблон для создания объектов, которые имеют как данные (атрибуты), так и поведение (методы).
* Объекты: Экземпляры класса, имеющие собственное уникальное состояние и поведение.

Полезные ссылки:

* [Principles of Object-Oriented Programming](https://khalilstemmler.com/articles/object-oriented/programming/4-principles/)
* [What are four basic principles of OOP?](https://medium.com/@cancerian0684/what-are-four-basic-principles-of-object-oriented-programming-645af8b43727)

##### Наследование

Наследование — это фундаментальное понятие объектно-ориентированного программирования (ООП), которое позволяет новому классу наследовать свойства и методы существующего класса. Класс, от которого наследуется, называется родительским или суперклассом, а класс, который наследует, называется дочерним или подклассом. Наследование позволяет повторно использовать код и обеспечивает иерархическую организацию классов, при которой дочерний класс может наследовать свойства и методы своего родительского класса и потенциально добавлять или переопределять их. Основное преимущество наследования заключается в том, что оно позволяет реализовать понятный и организованный способ повторного использования кода и пользоваться единожды написанным функционалом как в родительском, так и в дочерних классах.

Полезные ссылки:

* [What is inheritance in programming?](https://www.youtube.com/watch?v=ajOYOxCanhE)
* [Overview of Inheritance (object-oriented programming)](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))

##### Полиморфизм

Полиморфизм — это понятие объектно-ориентированного программирования (ООП), которая позволяет рассматривать объекты разных классов как объекты общего родительского класса. Это достигается путем определения общего интерфейса для всех классов, которые необходимо рассматривать полиморфно. Слово «полиморфизм» («многообразие форм», «многообразный») происходит от греческих слов «поли» (πολύ), что означает «много» и «морф» (μορφ) — «форма».

Существует два типа полиморфизма:

* Полиморфизм времени компиляции (также называемый статическим полиморфизмом или ранним связыванием) возникает, когда тип объекта, с которым будут проводиться определенные действия, определяется во время компиляции. Это достигается за счет перегрузки методов, которая позволяет нескольким методам иметь одно и то же имя, но разные параметры в одном классе.
* Полиморфизм времени выполнения (также называемый динамическим полиморфизмом или поздним связыванием) возникает, когда тип объекта определяется во время выполнения. Это достигается за счет переопределения методов, что позволяет дочернему классу предоставлять конкретную реализацию метода, который уже определен в его родительском классе.

Полезные ссылки:

* [Overview of Polymorphism in programming](https://www.bmc.com/blogs/polymorphism-programming/)
* [What is polymorphism in programming?](https://www.youtube.com/watch?v=tIWm3I_Zu7I)

##### Абстракция

Абстракция — это понятие объектно-ориентированного программирования (ООП), которое относится к процессу сокрытия деталей реализации объекта и раскрытию только его основных функций. Это позволяет использовать объекты без необходимости понимать всю сложность их внутренней структуры и поведения.

Существует два типа абстракции:

* Абстракция данных: относится к сокрытию внутреннего представления данных и выдаче их в упрощенном виде с помощью набора четко определенных интерфейсов.
* Абстракция поведения: относится к сокрытию внутреннего поведения объекта и реализация в упрощенной форме его возможностей с помощью набора четко определенных интерфейсов.

Полезные ссылки:

* [Tutorial - Abstraction](https://www.youtube.com/watch?v=OF55HZPE7lQ)
* [Абстракция данных](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

##### Инкапсуляция

Инкапсуляция — это понятие объектно-ориентированного программирования (ООП), которое относится к практике помещения внутренних данных и поведения объекта в определенный интерфейс и сокрытия деталей реализации от внешнего мира. Это одна из фундаментальных понятий ООП, тесно связанная с принципами сокрытия данных и сокрытия информации.

Инкапсуляция достигается за счет использования модификаторов доступа (таких как "public", "private" и "protected") для управления областью видимости и доступностью данных и методов объекта. Например, атрибуты класса могут быть объявлены как закрытые (приватные, "private"), т. е. доступ к ним возможен только с помощью методов внутри класса, а методы могут быть объявлены как открытые (публичные, "public"), т. е. их можно вызывать из любой части кода, имеющей ссылку на объект.

Полезные ссылки:

* [Overview of Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))
* [Википедия - Инкапсуляция (программирование)](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
* [Tutorial - What is encapsulation in programming?](https://www.youtube.com/watch?v=sNKKxc4QHqA)

## Принципы проектирования программного обеспечения

Существует множество принципов проектирования программного обеспечения, направленных на то, чтобы разрабатываемое программное обеспечение было легко понять, поддерживать и расширять. Некоторые из наиболее распространенных включают в себя:

* Принципы SOLID (принцип единой ответственности, принцип открытости/закрытости, принцип подстановки Лискова, принцип разделения интерфейса и принцип инверсии зависимостей)
* DRY (Не повторяйтесь)
* YAGNI (Вам это никогда не понадобится)
* KISS (Чем проще, тем лучше)
* LoD (Закон Деметры)
* Используйте композицию, а не наследование
* Инкапсулируйте то, что изменяется
* Голливудский принцип
* Пишите программы, основываясь на абстракциях

Следуя этим принципам проектирования, программное обеспечение может быть разработано таким образом, чтобы его было легко понять, поддерживать и расширять, а также оно было менее подвержено ошибкам.

Полезные ссылки:

* [Principles of Software Design](https://www.geeksforgeeks.org/principles-of-software-design/)
* [Software Design Principles For Beginners](https://www.youtube.com/watch?v=60EqoRcanpo)

### Используйте композицию, а не наследование

Композиция вместо наследования — это принцип программирования, который предполагает, что лучше использовать композицию, механизм сборки объектов, для создания сложных объектов, а не использовать наследование, которое представляет собой механизм создания новых классов на основе существующих.

Наследование — это мощный механизм для создания повторно используемого кода, но он также может привести к возникновению сильно связанного кода, который трудно поддерживать. Это связано с тем, что унаследованные классы сильно связаны со своими родительскими классами, и любые изменения, внесенные в родительский класс, повлияют на все его дочерние классы. Это затрудняет изменение или расширение кода без влияния на всю иерархию классов.

Полезные ссылки:

* [Tutorial - Composition over Inheritance](https://www.youtube.com/watch?v=wfMtDGfHWpA)
* [Overview of Composition over Inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)

### Инкапсулируйте то, что изменяется

Полезные ссылки:

* [Почему нужно инкапсулировать то, что изменяется?](https://ru.stackoverflow.com/questions/499882/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B8%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D1%82%D1%81%D1%8F)
* [What does it mean when one says “Encapsulate what varies”?](https://softwareengineering.stackexchange.com/questions/337413/what-does-it-mean-when-one-says-encapsulate-what-varies)
* [Overview of Encapsulate What Varies](https://bootcamp.uxdesign.cc/software-design-principles-every-developers-should-know-23d24735518e)

### Пишите программы, основываясь на абстракциях

Полезные ссылки:

* [What is Abstraction in Programming – And Why is it Useful?](https://www.freecodecamp.org/news/what-is-abstraction-in-programming/)
* [Overview of Abstraction principle](https://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming))

### Голливудский принцип

Полезные ссылки:

* [Tutorial - Hollywood Principle](https://www.youtube.com/watch?v=lRuygpsXE5s)

### SOLID

Полезные ссылки:

* [Get Started with SOLID](https://www.bmc.com/blogs/solid-design-principles/)
* [SOLID Principles](https://khalilstemmler.com/articles/tags/solid/)
* [Tutorial - What are SOLID principle?](https://www.youtube.com/watch?v=aUCo5cy32kE)

### DRY

Полезные ссылки:

* [What is DRY in programming?](https://www.youtube.com/watch?v=Rv3RIc_ziOY)
* [Overview of Don’t repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

### YAGNI

Полезные ссылки:

* [YAGNI (You Aren’t Gonna Need It) Principle Helps in Efficiency](https://builtin.com/software-engineering-perspectives/yagni)
* [What is YAGNI coding rule, and Why it helps?](https://www.youtube.com/watch?v=2vys1q1dKc4)

## Шаблоны проектирования

Полезные ссылки:

* [What Are Design Patterns?](https://www.youtube.com/watch?v=BWprw8UHIzA)
* [Overview - Software Design Pattern](https://en.wikipedia.org/wiki/Software_design_pattern)
* [Шаблон проектирования](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

### GoF шаблоны проектирования

Полезные ссылки:

* [Gangs of Four (GoF) Design Patterns](https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns)
* [Tutorial - Builder Pattern (Gang of Four Design Patterns Series)](https://www.youtube.com/watch?v=_sa2WlAFWQos)
* Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж. Паттерны объектно-ориентированного проектирования. — СПб.: Питер, 2020. — 448 с.: ил.

### PoSA шаблоны

Полезные ссылки:

* [POSA Pattern Examples](https://www.youtube.com/watch?v=iYNa_KcWxCU)
* [Overview of Pattern-Oriented Software Architecture](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)
* F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, M. Stal: Pattern-Oriented Software Architecture — A System of Patterns, John Wiley
and Sons, 2013.
* Brendan Burns, Designing Distributed Systems: Patterns and Paradigms for Scalable, Reliable Services, O'Reilly Media, 2018.
* [Pattern-Oriented Software Architecture](http://www.dre.vanderbilt.edu/~schmidt/POSA-tutorial.pdf)

## Архитектурные принципы

Полезные ссылки:

* [Intro to Architectural Principles](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles)
* [Principles of Software Design](https://www.youtube.com/watch?v=TO9igqkPtfc)

### Компонентно-ориентированное программирование

Полезные ссылки:

* [Component-Based Architecture](https://www.tutorialspoint.com/software_architecture_design/component_based_architecture.htm)

### Стратегия vs детали реализации

### Связанность (coupling) и связность (cohesion)

Полезные ссылки:

* [Low Coupling и High Cohesion](https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9)
* [Зацепление (программирование)](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
* [Cohesion and Coupling in Software Engineering](https://www.youtube.com/watch?v=NweTzHYBgYU)
* [Overview of Coupling and Cohesion](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/)

### Границы частей приложения

Полезные ссылки:

* [Boundaries in Software Architecture](https://www.open.edu/openlearn/science-maths-technology/approaches-software-development/content-section-1.1.4)

## Архитектурные стили

Полезные ссылки:

* [What is Software Architecture & Styles?](https://study.com/academy/lesson/software-architecture-styles-patterns-components.html)
* [Types of Architectural Styles in Software Engineering](https://www.youtube.com/watch?v=2Pp0BcXN9YY)
* [10 Architecture Patterns Used In Enterprise Software Development Today](https://www.youtube.com/watch?v=brt3ao8bvqy)

### по типу обмена сообщениями

Полезные ссылки:

[Architectural Styles in Software Engineering](https://shapingsoftware.com/2009/02/09/architectural-styles/)
[Architectural Messaging Patterns](https://www.redhat.com/architect/architectural-messaging-patterns)

#### основанный на событиях

Полезные ссылки:

[Overview of Event-driven programming](https://en.wikipedia.org/wiki/Event-driven_programming)
[What is event-driven architecture?](https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture)

#### издатель/подписчик

Полезные ссылки:

* [Publish-Subscribe Architecture (Explained by Example)](https://www.youtube.com/watch?v=O1PgqUqZKTA)
* [Tutorial - Publish–subscribe pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)

### по способу взаимодействия в распределенной сети

Полезные ссылки:

* [Overview of Distributed Architecture](https://www.tutorialspoint.com/software_architecture_design/distributed_architecture.htm)

#### клиент-сервер

Полезные ссылки:

* [Intro to Client-server Architecture](https://cs.uwaterloo.ca/~m2nagapp/courses/CS446/1195/Arch_Design_Activity/ClientServer.pdf)

#### одноранговое, децентрализованное или пиринговое (peer-to-peer, P2P)

Полезные ссылки:

* [Peer to Peer Architecture](https://student.cs.uwaterloo.ca/~cs446/1171/Arch_Design_Activity/Peer2Peer.pdf)

### по внутренней структуре

#### компонентно-ориентированная

Полезные ссылки:

* [Component Based Software architecture](https://www.tutorialspoint.com/software_architecture_design/component_based_architecture.htm)

#### монолитная

Полезные ссылки:

* [Overview of Monolithic Architecture](https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith)
* [What is Monolithic architecture?](https://www.techtarget.com/whatis/definition/monolithic-architecture)
* [What is Software Architecture? (Monolithic vs. Layered vs. Microservice)s](https://www.youtube.com/watch?v=_07NtoK-Kns)

#### многоуровневая

Полезные ссылки:

* [Layered Architectures](https://www.youtube.com/watch?v=0kpTKLTx8f4)
* [Get started with Layered Architecture](https://cs.uwaterloo.ca/~m2nagapp/courses/CS446/1195/Arch_Design_Activity/Layered.pdf)

## Архитектурные шаблоны

Полезные ссылки:

* [Overview - Architectural Pattern](https://en.wikipedia.org/wiki/Architectural_pattern)
* [Architecture Patterns Used In Enterprise Software Development](https://www.youtube.com/watch?v=BrT3AO8bVQY)

### SOA

Полезные ссылки:

* [Overview of Service-Oriented Architecture](https://medium.com/design-microservices-architecture-with-patterns/service-oriented-architecture-1e4716fbca17)
* [Tutorial - Service-Oriented Architecture -SOA](https://www.youtube.com/watch?v=jNiEMmoTDoE)
* [What is Service-Oriented Architecture
](https://www.youtube.com/watch?v=_dFJOSR-aFs)

### CQRS

Полезные ссылки:

* [Get Started with CQRS Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)
* [CQRS Software Architecture Pattern: The Good, Bad, and the Ugly](https://betterprogramming.pub/cqrs-software-architecture-pattern-the-good-the-bad-and-the-ugly-e9d6e7a34daf)

### Предметно-ориентированное проектирование

### Модель-представление-контроллер (Model-View-Controller)

### Микросервисы

### Шаблон Blackboard («доска объявлений»)

### Микроядро

### Бессерверная архитектура

Полезные ссылки:

* [Serverless Architecture Patterns in AWS](https://waswani.medium.com/serverless-architecture-patterns-in-aws-edeab0e46a32)

### Очереди сообщений / потоки

Полезные ссылки:

* [System Design — Message Queues](https://medium.com/must-know-computer-science/system-design-message-queues-245612428a22)
* [Overview of Message Queue pattern](https://badia-kharroubi.gitbooks.io/microservices-architecture/content/patterns/communication-patterns/message-queue-pattern.html)

### Генерация событий (Источники событий, Event Sourcing)

Полезные ссылки:

* [Event Sourcing Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
* [Design Patterns: Why Event Sourcing?](https://www.youtube.com/watch?v=rUDN40rdly8)

## Шаблоны корпоративных приложений

Шаблоны корпоративных приложений — это набор шаблонов проектирования, которые обычно используются при разработке корпоративного программного обеспечения. Эти шаблоны содержат словарь часто употребляемых терминов и набор лучших практик для решения часто встречающихся проблем, возникающих при разработке больших и сложных программных систем. Ниже приведены некоторые примеры шаблонов корпоративных приложений:

* Предметно-ориентированное проектирование (DDD)
* Модель-представление-контроллер (MVC)
* Сервис-ориентированная архитектура (SOA)
* Принцип разделения ответственности на команды и запросы (CQRS)
* Генерация событий (Event Sourcing)
* Микросервисы
* Событийно-ориентированная архитектура (EDA)

Эти шаблоны могут помочь улучшить поддержку и масштабируемость программного обеспечения, обеспечивая четкое разделение задач и позволяя использовать более модульную и гибкую архитектуру.

Полезные ссылки:

* [Software Architecture Patterns in Enterprise Software](https://blog.devgenius.io/10-software-architecture-patterns-in-enterprise-software-development-fabacb5ed0c8)
* [What are Enterprise Integration Patterns?](https://www.youtube.com/watch?v=WNm3QmJadNs)

### Объекты переноса данных (DTOs)

Шаблон проектирования Объект переноса данных — это один из архитектурных шаблонов корпоративных приложений, который требует использовать объекты, объединяющие и инкапсулирующие данные для передачи. Объект переноса данных, по сути, подобен структуре данных. Он не должен содержать никакой бизнес-логики, но должен содержать механизмы сериализации и десериализации.

Полезные ссылки:

* [Data Transfer Object](https://martinfowler.com/eaaCatalog/dataTransferObject.html)
* [Data Transfer Object pattern and Mappers](https://medium.com/@abdalrhmanalkraien/data-transfer-object-pattern-and-mapper-116508bc9df0)

### Коллекции объектов (Identity Maps)

Коллекции объектов — это шаблон, используемый при разработке корпоративных приложений для поддержки карты объектов, которые были загружены из базы данных, где ключом является их уникальный идентификатор. Они используются для предотвращения создания в памяти нескольких копий одного и того же объекта при многократном доступе к одним и тем же данным.

Шаблон Коллекция объектов обычно используется в сочетании с таким инструментом как ORM (объектно-реляционным отображением). Перед тем как объект извлекается из базы данных, сначала происходит сверка с коллекцией объектов, чтобы убедиться, что он уже не был загружен ранее. Если
он уже находится в коллекции, то возвращается существующий объект, а не создается новая копия.

Полезные ссылки:

* [Identity Map](https://martinfowler.com/eaaCatalog/identityMap.html)
* [Overview of Identity map pattern](https://en.wikipedia.org/wiki/Identity_map_pattern)
* [Tutorial - Identity Map Design Pattern](https://youtube.com/watch?v=erDxkIyNudY)

### Особые случаи использования (Use Cases)

Особые случаи использования — это шаблон, применяемый при разработке корпоративных приложений для представления функциональных требований системы. Они описывают взаимодействие между системой и её пользователями, а также шаги, необходимые для достижения конкретной цели. Особые случаи использования — это способ зафиксировать требования к системе таким образом, чтобы их было легко понять как команде разработчиков, так и заинтересованным сторонам.

Особый случай использования — это описание последовательности действий, которые система выполняет в ответ на запрос пользователя для достижения определенной цели. Особый случай использования обычно включает в себя:

* Áктор (пользователь), который инициирует действие
* Цель, которую хочет достичь а́ктор
* Шаги, необходимые для достижения цели, включая любые альтернативные пути или условия, приводящие к ошибке
* Ожидаемый результат взаимодействия

Особые случаи использования часто являются основопологающими при проектировании и разработке системы, поскольку они обеспечивают чёткое и более глубокое понимание требований к ней.

Полезные ссылки:

* [Use Case Patterns](https://caminao.blog/how-to-implement-symbolic-representations/patterns/functional-patterns/use-case-patterns/)

### Репозитории (Repositories)

Репозитории — это шаблон, используемый при разработке корпоративных приложений для обеспечения согласованного и абстрактного способа доступа к хранилищу данных. Репозитории по сути являются уровнем абстракции между приложением и хранилищем данных, предоставляя согласованный и простой API для доступа к данным и манипулирования ими.

Репозиторий — это шаблон, который можно использовать для организации кода доступа к данным и инкапсуляции логики извлечения и хранения объектов. Репозитории обеспечивают отделение проблемы доступа к данным от остальной части приложения, позволяя писать код приложения для интерфейса, а не для конкретной технологии хранения данных.

Полезные ссылки:

* [Repository](https://martinfowler.com/eaaCatalog/repository.html)
* [Tutorial - Repository Design Pattern](https://www.youtube.com/watch?v=mb6bwnEaZ3U)
* [Introduction to Repository Design Patterns](https://cubettech.com/resources/blog/introduction-to-repository-design-pattern/)

### Преобразователи (Mappers)

Преобразователи — это шаблон, используемый при разработке корпоративных приложений для обеспечения согласованного и абстрактного способа сопоставления между различными моделями данных. Они по сути представляют собой уровень абстракции между приложением и хранилищем данных, предоставляя согласованный и простой API для преобразования данных.

Преобразователь — это компонент, который можно использовать для перевода данных из одного формата или модели в другой. Например, его можно использовать для преобразования данных из модели базы данных в модель предметной области или из модели предметной области в объект переноса данных (DTO).

Полезные ссылки:

* [Mapper](https://martinfowler.com/eaaCatalog/mapper.html)
* [Overview of Data Mapper Pattern](https://en.wikipedia.org/wiki/Data_mapper_pattern)
* [Tutorial - Mappers](https://www.youtube.com/watch?v=7noMLStHcTE)

### Сценарий транзакции (Transaction Script)

Сценарий транзакции — это шаблон, используемый в разработке корпоративных приложений, который организует бизнес-логику в единый процедурный сценарий. Он часто используется для простых операций CRUD (создание, чтение, обновление, удаление), где вся логика для конкретной транзакции содержится в одном скрипте или функции. Этот шаблон прост в реализации и понятен, но может стать громоздким по мере увеличения сложности приложения. Альтернативные шаблоны, такие как предметно-ориентированное проектирование (DDD) и шаблон Active Record, могут лучше подходить для более сложных приложений.

Полезные ссылки:

* [Transaction Script](https://martinfowler.com/eaaCatalog/transactionScript.html)
* [Transaction Script Pattern](https://gunnarpeipman.com/transaction-script-pattern/)
* [Tutorial - Transaction Script Design Pattern](https://www.youtube.com/watch?v=fnsU9cqcY3I)

### Команды / Запросы (Commands / Queries)

Шаблон разделения ответственности на команды и запросы (CQRS) — это методика, используемая при разработке корпоративных приложений для разделения обязанностей по обработке операций, связанных с записью (команд), от операций, связанных с чтением (запросов), для выполнении действий, которые изменяют состояние системы, таких как создание, обновление или удаление данных. Эти операции реализуются обработчиками команд, которые отвечают за проверку данных и выполнение соответствующей бизнес-логики.

Запросы используются для извлечения данных из системы, например для чтения данных из базы данных или кэша. Эти операции осуществляются обработчиками запросов, которые отвечают за выполнение соответствующего запроса и возврат данных вызывающей стороне.

Полезные ссылки:

* [Get Started with CQRS Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)

### Объекты-значения (Value Objects)

Объекты-значения — это шаблон, используемый в разработке корпоративных приложений для представления простых неизменяемых значений, используемых для моделирования понятий предметной области. Обычно они используются для инкапсуляции данных, которые не являются сущностью, но важны для предметной области.

Объект-значение определяется своим значением, не имеет собственной идентичности, уникальности, что означает, что два объекта-значения с одинаковым значением считаются равными, независимо от их идентичности.

Полезные ссылки:

* [Value Object](https://martinfowler.com/eaaCatalog/valueObject.html)
* [Overview - Implement Value Objects](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/implement-value-objects)
* [Intro to Value object](https://en.wikipedia.org/wiki/Value_object)

### Модели предметной области (Domain Models)

Модели предметной области — это шаблон, используемый при разработке корпоративных приложений для представления бизнес-концепций и правил конкретной предметной области. Обычно они используются для моделирования проблемной области или области знаний конкретного бизнеса.

Модель предметной области — это набор объектов, которые представляют реальные понятия и сущности предметной области. Эти объекты обычно моделируются как классы или типы и инкапсулируют данные и поведение, специфичные для предметной области. Они несут ответственность за представление состояния и поведения бизнес-концепций, которые они моделируют, а также за соблюдение правил и ограничений предметной области.

Полезные ссылки:

* [Domain Model](https://martinfowler.com/eaaCatalog/domainModel.html)
* [Overview - Domain Models](https://sparxsystems.com/enterprise_architect_user_guide/14.0/model_domains/specialized_models.html)
* [Tutorial - Domain Model Pattern](https://www.youtube.com/watch?v=75EGANiqADw)

### Сущности (Entities)

Сущности — это шаблон, используемый в разработке корпоративных приложений для представления бизнес-концепций с уникальным идентификатором и временем существования. Обычно они используются для моделирования реальных объектов или понятий, которые имеют четкую идентичность и жизненный цикл, например клиент, заказ или учётная запись.

Сущность определяется своей идентичностью, что означает, что две сущности с одной и той же идентичностью считаются одним и тем же, независимо от их состояния. Сущности обычно имеют уникальный идентификатор, например первичный ключ, который используется для их идентификации. У них также есть связанный набор свойств или атрибутов, описывающих их состояние.

Полезные ссылки:

* [What is entity in a programming language?](https://www.quora.com/What-is-entity-in-a-programming-language)

### Объектно-реляционные отображения (ORMs)

ORM расшифровывается как Object-Relational Mapping (Объектно-реляционное отображение), это методика, используемая при разработке корпоративных приложений для сопоставления между моделью объектно-ориентированного программирования и моделью реляционной базы данных. Это позволяет разработчикам работать с объектами в своем коде, в то время как инструмент ORM заботится о переводе этих объектов в соответствующие операции с базой данных.

ORM предназначены для того, чтобы абстрагироваться от сложности работы с реляционной базой данных и позволить разработчикам взаимодействовать с базой данных с помощью объектно-ориентированного API более высокого уровня. Они предоставляют набор библиотек и инструментов, которые сопоставляют объекты в коде с таблицами и строками в базе данных и наоборот. Это позволяет разработчикам работать с данными, используя знакомую объектно-ориентированную парадигму, вместо того, чтобы писать сложные SQL-запросы.

Полезные ссылки:

* [Why do you need an ORM?](https://enterprisecraftsmanship.com/posts/do-you-need-an-orm/)

---------------------------------------------------------------------------------------------------------------------------
1. Вервов Вон. Предметно-ориентированное проектирование: самое основное.: Пер. с англ. - СпВ.: ООО "Альфа-книга". 2017. - 160 с.: ил. - Парал. тит. англ.
2. Вернов Вон. Реализация методов предметно-ориентированного проектирования.: Пер. с англ. - М.: ООО "И.Д. Вильямс", 2016. - 688 с.: ил. - Парал. тит. англ.
3. Фаулер, Мартин. Шаблоны корпоративных приложений.: Пер. с англ. - М.: ООО "И. Д. Вильямс", 2016. - 544 с.: ил. - Парал. тит. англ.
4. Эванс Эрик. Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем.: Пер. с англ. М.: ООО "И. Д. Вильямс", 2011. - 448 с.: ил. - Парал. тит. англ.
---------------------------------------------------------------------------------------------------------------------------

**Замечание.** Список, приведённый в данной дорожней карте, не является исчерпывающим. Здесь приведены лишь некоторые из наиболее важных тем, касающиеся каждого раздела.
