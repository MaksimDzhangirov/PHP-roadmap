# Дорожная карта для изучения Docker

[Оригинал](https://roadmap.sh/docker)

Дорожная карта была составлена в сотрудничестве с [Сидом Паласом (Sid Palas)](https://twitter.com/sidpalas). Ознакомьтесь с его
[бесплатным курсом, подробно освещающим эту тему](https://courses.devopsdirective.com/docker-beginner-to-pro).

[Дорожная карта для изучения Kubernetes](https://roadmap.sh/kubernetes)

[Дорожная карта DevOps](https://roadmap.sh/devops)

[Дорожная карта Backend-разработчика](https://roadmap.sh/backend)

Необходимые предварительные знания для изучения данного материала:

* из области веб-разработки
  * архитектура приложения
  * языки программирования
* основ Linux
  * менеджеры пакетов
  * права доступа для пользователей/групп
  * команды оболочки командной строки
  * скрипты оболочки командной строки
 
## Введение

**Что такое Docker?**

Docker – это платформа с открытым исходным кодом, которая автоматизирует развертывание, масштабирование и управление приложениями, изолируя их в легковесные портативные контейнеры. Контейнеры – это автономные исполняемые модули, которые инкапсулируют все необходимые зависимости, библиотеки и файлы конфигурации, необходимые для единообразной работы приложения в различных средах.

### Что такое контейнеры?

Контейнеры – это легковесные, портативные и изолированные программные среды, которые позволяют разработчикам запускать и упаковывать приложения с их зависимостями единообразно на разных платформах. Они помогают оптимизировать процессы разработки, развертывания и управления приложениями, обеспечивая при этом единообразную работу приложений независимо от базовой инфраструктуры.

#### Как работают контейнеры?

В отличие от традиционной виртуализации, которая эмулирует всю операционную систему с ее аппаратными ресурсами, контейнеры совместно используют ядро ОС хоста и упрощенные методы виртуализации для создания изолированных процессов. Такой подход дает ряд преимуществ, в том числе:

* **Эффективность**: контейнеры требуют меньше накладных расходов и могут совместно использовать общие библиотеки и исполняемые файлы, что позволяет запускать больше контейнеров на одном хосте по сравнению с виртуальными машинами (ВМ).
* **Переносимость**: контейнеры инкапсулируют приложения и их зависимости, поэтому их можно легко перемещать и единообразно запускать в разных средах и платформах.
* **Быстрый запуск**: поскольку контейнерам не требуется загрузка полной ОС, они могут запускаться и завершать работу гораздо быстрее, чем виртуальные машины.
* **Единообразность**: контейнеры обеспечивают единообразную среду для этапов разработки, тестирования и продакшена приложения, уменьшая проблему «оно работает на моей машине».

#### Контейнеры и Docker

Docker – это платформа, которая упрощает процесс создания, развертывания и управления контейнерами. Она предоставляет разработчикам и администраторам набор инструментов и API для управления контейнерными приложениями. С помощью Docker вы можете создавать и упаковывать код приложения, библиотеки и зависимости в образ контейнера, который можно распространять и единообразно запускать в любой среде, поддерживающей Docker.

Полезные ссылки:

* [What is a container?](https://www.docker.com/resources/what-container/)

### Зачем нам нужны контейнеры?

В мире разработки и развертывания программного обеспечения решающее значение имеют единообразность и эффективность. До того, как появились контейнеры, разработчики часто сталкивались с проблемами при развертывании приложений в различных средах, в том числе:

* **Несовместимые среды**: разработчики часто работают в разных средах, которые могут иметь разные конфигурации и библиотеки по сравнению с продакшен серверами. Это приводит к проблемам совместимости при развертывании приложений.

* **Неэффективное использование ресурсов**: виртуальные машины (ВМ) широко использовались для устранения несовместимости среды. Однако виртуальные машины требуют, чтобы для каждого приложения работала целая ОС, что приводит к неэффективному использованию ресурсов.

* **Проблемы, связанные с медленным процессом внедрения и масштабируемостью**: традиционным методам развертывания требуется больше времени до выпуска решения на рынок и их трудно масштабировать, что затрудняет быстрое внедрение обновлений программного обеспечения.

Как контейнеры решают эти проблемы:

* **Единообразная среда**: контейнеры устраняют несогласованность среды, объединяя приложение и его зависимости, конфигурации и библиотеки в один контейнер. Это гарантирует бесперебойную работу приложения в различных средах.

* **Эффективное использование ресурсов**. В отличие от виртуальных машин, контейнеры совместно используют базовые системные ресурсы и ядро ОС, что делает их легковесными и эффективными. Контейнеры создавались таким образом, чтобы использовать меньшее количество ресурсов и для более быстрой загрузки, что улучшает использование ресурсов.

* **Ускорение процесса внедрения и масштабируемость**. Контейнеры можно легко создавать, уничтожать и заменять, что приводит к ускорению циклов разработки и развертывания. Масштабирование приложений упрощается, поскольку можно развернуть несколько контейнеров без потребления значительных ресурсов.

В целом контейнеры стали важным инструментом для организаций, которые хотят быстро реагировать на изменения рынка, повышать эффективность использования ресурсов и обеспечивать надежную и единообразную доставку программного обеспечения. Они произвели революцию в современной практике разработки программного обеспечения и оказали долгосрочное влияние на мир развертывания и управления приложениями.

Полезные ссылки:

* [Introduction to containers - AWS Skill Builder](https://explore.skillbuilder.aws/learn/course/106/introduction-to-containers)

### Bare Metal, виртуальные машины и контейнеры

Вот краткий обзор различий между bare metal, виртуальными машинами и контейнерами.

#### Bare Metal

Bare Metal («голое железо») – это термин, используемый для описания компьютера, который работает непосредственно на оборудовании без какой-либо виртуализации. Это наиболее производительный способ запуска приложения, но он также и наименее гибкий. Вы можете запускать только одно приложение на каждом сервере и вы не можете легко переместить приложение на другой сервер.

#### Виртуальные машины

Виртуальные машины (ВМ) – это способ запуска нескольких приложений на одном сервере. Каждая виртуальная машина работает поверх гипервизора – программного обеспечения, эмулирующего аппаратное обеспечение компьютера. Гипервизор позволяет запускать несколько операционных систем на одном сервере, а также обеспечивает изоляцию между приложениями, работающими на разных виртуальных машинах.

#### Контейнеры

Контейнеры – это способ запуска нескольких приложений на одном сервере без затрат на гипервизор. Каждый контейнер работает поверх механизма контейнера, который представляет собой часть программного обеспечения, эмулирующую операционную систему компьютера. Механизм контейнеров позволяет запускать несколько приложений на одном сервере, а также обеспечивает изоляцию между приложениями, работающими в разных контейнерах.

Полезные ссылки:

* [History of Virtualization](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/01-history-and-motivation/03-history-of-virtualization)

### Docker и OCI

[Open Container Initiative (OCI)](https://opencontainers.org/) – это проект Linux Foundation, целью которого является создание отраслевых стандартов для форматов контейнеров и сред выполнения. Его основная цель – обеспечить совместимость и взаимодействие контейнерных сред посредством определенных технических спецификаций.

#### Роль Docker в OCI

[Docker](https://www.docker.com/) является одним из основателей OCI и сыграл ключевую роль в формировании стандартов форматов контейнеров и сред выполнения. Docker изначально разработал среду выполнения контейнера (Docker Engine) и формат образа (Docker Image), которые служат основой для спецификаций OCI.

#### Спецификации OCI

OCI имеет две основные спецификации:

* **Спецификация среды выполнения (runtime-spec)**: определяет спецификацию среды выполнения контейнера с помощью технологии изоляции, например, механизма контейнера. Среда выполнения контейнера, созданная Docker и называемая «containerd», послужила основой для разработки OCI runtime-spec.
* **Спецификация образа (image-spec)**: определяет формат образа контейнера, который описывает содержимое контейнера и может запускаться совместимой средой выполнения. Первоначальный формат образа Docker привел к созданию OCI image-spec.

#### Совместимость между Docker и OCI

Docker сохраняет приверженность к поддержке спецификаций OCI и с момента своего участия в OCI постоянно обновляет свое программное обеспечение, чтобы оно соответствовало стандартам OCI. Среда выполнения контейнера и формат образа Docker полностью совместимы со спецификациями OCI, что позволяет запускать контейнеры Docker другими средами выполнения контейнеров, совместимыми с OCI, и наоборот.

Таким образом, Docker и Open Container Initiative работают сообща, чтобы поддерживать стандартизацию и совместимость в контейнерной индустрии. Docker сыграл значительную роль в разработке спецификаций OCI, гарантируя, что экосистема контейнеров останется работоспособной, функциональной и доступной для широкого круга пользователей и платформ в отрасли.

## Технологии, лежащие в основе

Достаточно иметь общее представление о них.

Понимание основных технологий, лежащих в основе Docker, даст вам более глубокое осмысление того, как работает Docker, и поможет вам более эффективно использовать платформу.

#### Контейнеры Linux (LXC)

Контейнеры Linux (LXC) служат основой Docker. LXC – это легковесное решение для виртуализации, которое позволяет нескольким изолированным системам Linux работать на одном хосте без необходимости использования полноценного гипервизора. LXC эффективно изолирует приложения и их зависимости безопасным и оптимизированным способом.

#### Контрольные группы (cgroups)

Контрольные группы (cgroups) – это функция ядра Linux, которая позволяет распределять и управлять такими ресурсами, как ЦП, память и ввод-вывод, набору процессов. Docker использует контрольные группы, чтобы ограничить ресурсы, используемые контейнерами, и гарантировать, что один контейнер не монополизирует ресурсы хост-системы.

#### Файловые системы типа Union

UnionFS – это служба файловой системы, которая позволяет накладывать несколько файловых систем, формируя единое унифицированное представление. Docker использует UnionFS для создания многоуровневого подхода к образам и контейнерам, что обеспечивает лучший обмен общими файлами и более быстрое создание контейнеров.

#### Пространства имён

Пространства имён – ещё одна функция ядра Linux, обеспечивающая изоляцию процессов. Они позволяют Docker создавать изолированные рабочие области, называемые контейнерами. Пространства имен гарантируют, что процессы внутри контейнера не могут мешать процессам вне контейнера или в хост-системе. Существует несколько типов пространств имен, таких как PID, NET, MNT и USER, каждый из которых отвечает за изоляцию определенного аспекта процесса.

### Пространство имён

Пространства имён – одна из основных технологий, которые Docker использует для обеспечения изоляции между контейнерами. В этом разделе мы кратко обсудим, что такое пространства имён и как они работают.

#### Что такое пространства имён?

В ядре Linux пространства имен – это функционал, который позволяет изолировать различные системные ресурсы, позволяя процессу и его дочерним элементам работать в обособленном подмножестве системы, отдельном от других процессов. Пространства имён помогают создать уровень абстракции, позволяющий хранить контейнерные процессы отдельно друг от друга и от хост-системы.

В Linux существует несколько типов пространств имен, а именно:

* **PID (идентификаторы процессов)**: изолирует пространство номеров идентификаторов процессов. Это означает, что процессы внутри контейнера видят только свои собственные процессы, а не процессы на хосте или в других контейнерах.
* **Сеть (NET)**: предоставляет каждому контейнеру отдельное представление сетевого стека, включая собственные сетевые интерфейсы, таблицы маршрутизации и правила брандмауэра.
* **Монтирование (MNT)**: изолирует точки монтирования файловой системы таким образом, что каждый контейнер имеет собственную корневую файловую систему, а смонтированные ресурсы видны только внутри этого контейнера.
* **UTS (система разделения времени UNIX)**: позволяет каждому контейнеру иметь собственное имя хоста и имя домена, отдельно от других контейнеров и хост-системы.
* **Пользователь (USER)**: сопоставляет идентификаторы пользователя и группы между контейнером и хостом, поэтому для ресурсов внутри контейнера можно устанавливать разные права доступа.
* **IPC (межпроцессное взаимодействие)**: разрешает или ограничивает взаимодействие между процессами в разных контейнерах.

#### Как Docker использует пространства имен

Docker использует пространства имен, создавая изолированные среды для контейнеров. Когда контейнер запускается, Docker создает для этого контейнера новый набор пространств имен. Эти пространства имен действуют только внутри контейнера, поэтому любые процессы, работающие внутри контейнера, имеют доступ к подмножеству системных ресурсов, изолированных от других контейнеров, а также от хост-системы.

Используя пространства имен, Docker гарантирует, что контейнеры действительно переносимы и могут работать в любой системе без конфликтов или вмешательства со стороны других процессов или контейнеров, работающих на том же хосте.

Подводя итог, можно сказать, что пространства имен обеспечивают уровень изоляции ресурсов, который позволяет запускать несколько контейнеров с отдельными системными ресурсами на одном хосте, не мешая им друг другу. Это важнейшая функция, которая составляет основу контейнерной технологии Docker.

### cgroups

**cgroups** или **контрольные группы** – это функционал ядра Linux, которая позволяет вам распределять и управлять ресурсами, такими как ЦП, память, пропускная способность сети и ввод-вывод, между группами процессов, запущенных в системе. Он играет решающую роль в обеспечении изоляции ресурсов и ограничении ресурсов, которые может использовать работающий контейнер.

Docker использует cgroups для обеспечения соблюдения ограничений ресурсов в контейнерах, позволяя им иметь единообразное и предсказуемое поведение. Ниже приведены некоторые ключевые функции и преимущества cgroups в контексте контейнеров Docker:

#### Изоляция ресурсов

cgroups помогает ограничить каждый контейнер определенным набором ресурсов, гарантируя справедливое разделение системных ресурсов между несколькими контейнерами. Это обеспечивает лучшую изоляцию между различными контейнерами, так что сбоящий контейнер не потребляет все доступные ресурсы, тем самым негативно влияя на другие контейнеры.

#### Ограничение ресурсов

С помощью cgroups вы можете установить ограничения на различные системные ресурсы, используемые контейнером, такие как процессор, память и ввод-вывод. Это помогает предотвратить потребление чрезмерных ресурсов одним контейнером и возникновение проблем с производительностью других контейнеров или хост-системы.

#### Приоритизация контейнеров

Выделяя различные доли ресурсов, cgroups позволяет вам отдавать предпочтение или приоритет определенным контейнерам. Это может быть полезно в случаях, где некоторые контейнеры более критичны, чем другие, или в ситуациях с высокой конкуренцией за ресурсы.

#### Мониторинг

cgroups также предлагает механизмы мониторинга использования ресурсов отдельными контейнерами, что помогает получить представление о производительности контейнеров и выявить потенциальные узкие места в ресурсах.

В целом, cgroups – это важная базовая технология Docker. Используя cgroups, Docker обеспечивает надежную и эффективную среду выполнения контейнеров, гарантируя, что контейнеры имеют необходимые ресурсы, сохраняя при этом хорошую общую производительность системы.

### Файловые системы типа Union

Файловые системы типа Union, также известные как UnionFS, играют решающую роль в общем функционировании Docker. Это уникальный тип файловой системы, который создает виртуальную многоуровневую файловую структуру путем наложения нескольких каталогов. Вместо изменения исходной файловой системы или объединения каталогов UnionFS позволяет одновременно монтировать несколько каталогов в одной точке монтирования, сохраняя при этом их содержимое отдельно. Эта функция особенно полезна в контексте Docker, поскольку позволяет нам контролировать и оптимизировать производительность хранилища за счет минимизации дублирования и уменьшения размера образа контейнера.

Вот некоторые из основных особенностей файловых систем типа Union:

* **Многоуровневая структура**: UnionFS создает многоуровневую структуру, состоящую из нескольких слоев, доступных только для чтения, и верхнего слоя, доступного для записи. Эта структура позволяет эффективно обрабатывать изменения, обновляя только записываемый слой, в то время как слои, доступные только для чтения, сохраняют исходные данные.

* **Копирование при записи**: Механизм копирования при записи (COW) является незаменимой функцией UnionFS. Если контейнер вносит изменения в существующий файл, система создает копию файла в доступном для записи слое, оставляя исходный файл в слое только для чтения нетронутым. Этот процесс ограничивает модификацию самым верхним слоем, обеспечивая быструю и ресурсоэффективную работу.

* **Совместное использование ресурсов**: файловые системы типа Union позволяют нескольким контейнерам использовать общие базовые слои при раздельной работе. Эта функция предотвращает дублирование ресурсов и экономит значительное место под хранение.

* **Быстрая инициализация контейнера**: Файловые системы типа Union позволяют мгновенно создавать новые контейнеры, просто создавая новый записываемый слой на существующих слоях, доступных только для чтения. Такая быстрая инициализация снижает накладные расходы на дублированные файловые операции, что в конечном итоге повышает производительность.

#### Популярные файловые системы типа Union в Docker

Docker поддерживает несколько файловых систем типа Union, которые упрощают создание контейнеров и управление ими. Некоторыми из популярных вариантов явлются:

* **AUFS (расширенная многоуровневая унифицированная файловая система)**: AUFS широко используется в качестве драйвера хранилища Docker, обеспечивая эффективное управление несколькими слоями.
* **OverlayFS (файловая система Overlay)**: OverlayFS – ещё одна файловая система типа Union, поддерживаемая Docker. Он использует упрощенный подход по сравнению с AUFS для создания и управления наложенными друг на друга каталогами.
* **Btrfs (файловая система B-Tree)**: Btrfs, современная файловая система, обеспечивает совместимость с файловыми системами типа Union в дополнение к расширенным функциям хранения, таким как снимки состояния файлов и контрольные суммы.
* **ZFS (файловая система Z)**: ZFS – это высокопроизводительная и надежная платформа хранения, которая обеспечивает функции файловой системы типа Union, а также защиту данных, сжатие и дедупликацию.

## Установка/Настройка

Docker предоставляет настольное приложение под названием **Docker Desktop**, которое упрощает процесс установки и настройки. Существует также другой вариант установки с помощью **Docker Engine**.

Полезные ссылки:

* [Docker Desktop website](https://www.docker.com/products/docker-desktop)
* [Docker Engine](https://docs.docker.com/engine/install/)

### Docker Desktop (Win/Mac/Linux)

Docker Desktop – это простое в установке приложение, которое позволяет разработчикам быстро настроить среду Docker на своих настольных компьютерах. Оно доступно как для операционных систем Windows, так и для MacOS. Docker Desktop предназначен для упрощения процесса управления и запуска контейнеров Docker, обеспечивая удобный интерфейс и бесшовную интеграцию с операционной системой хоста.

**Характерные особенности**

* **Простота установки**: Docker Desktop обеспечивает простой процесс установки, позволяя пользователям быстро настроить Docker на своих компьютерах.
* **Автоматические обновления**: Приложение автоматически обновится до последней версии Docker, гарантируя актуальность и безопасность вашей среды.
* **Интеграция с Docker Hub**: Интерфейс Docker Desktop обеспечивает легкий доступ к Docker Hub, позволяя пользователям находить, делиться и управлять Docker образами.
* **Управление контейнерами и сервисами**: Docker Desktop упрощает управление контейнерами и сервисами благодаря удобному графическому интерфейсу, который позволяет пользователям следить за состоянием, запускать, останавливать и удалять контейнеры и сервисы.
* **Интеграция с Kubernetes**: Docker Desktop поставляется со встроенной поддержкой Kubernetes, которую можно включить одним щелчком мыши. Это упрощает разработку, тестирование и запуск Kubernetes приложений локально.
* **Распределение ресурсов**: Docker Desktop позволяет пользователям настраивать объем ресурсов (ЦП, оперативной памяти и твердотельного или дискового накопителя), выделяемых контейнерам и службам.

**Установка**

Чтобы установить Docker Desktop на свой компьютер, выполните следующие действия:

* **Загрузите установщик**. Вы можете загрузить установщик для своей операционной системы с [веб-сайта Docker Desktop](https://www.docker.com/products/docker-desktop). Обязательно выберите подходящую версию (Windows или Mac).
* **Запустите установщик**: дважды щелкните по загруженному файлу установщика и следуйте указаниям мастера установки, чтобы завершить процесс установки.
* **Запустите Docker Desktop**: После завершения установки запустите Docker Desktop и войдите в свою учетную запись Docker Hub. Если у вас нет учетной записи, вы можете зарегистрировать бесплатную учетную запись на [веб-сайте Docker Hub](https://hub.docker.com/).
* **Проверьте корректность установки**: откройте терминал или командную строку и выполните следующую команду, чтобы убедиться, что Docker Desktop установлен правильно:

```shell
docker --version
```

Если установка прошла успешно, команда должна вывести информацию о версии Docker.

Полезные ссылки:

* [Docker Desktop Documentation](https://docs.docker.com/desktop/)
* [Docker Get Started Guide](https://docs.docker.com/get-started/)
* [Docker Hub](https://hub.docker.com/)

### Docker Engine (Linux)

Часто путают понятия «Docker Desktop» и «Docker Engine». Docker Engine относится конкретно к подмножеству компонентов Docker Desktop, которые являются бесплатными, с открытым исходным кодом и могут быть установлены только в Linux.

Docker Engine включает в себя:

* Интерфейс командной строки Docker (CLI)
* Демон Docker (dockerd), предоставляющий интерфейс прикладного программирования (API) Docker.

Docker Engine может создавать образы контейнеров, запускать контейнеры из них и, как правило, позволяет реализовать большую часть из того, что доступно в Docker Desktop, но предназначен только для Linux и не обеспечивает всех тех возможностей для разработчиков, которые предоставляет Docker Desktop.

Полезные ссылки:

* [Docker Engine - Docker Documentation](https://docs.docker.com/engine/)

## Основы Docker

Docker – это платформа, которая упрощает процесс создания, упаковки и развертывания приложений в легковесных портативных контейнерах. В этом разделе мы рассмотрим основы Docker, его компоненты и ключевые команды, необходимые для начала работы.

### Что такое контейнер?

Контейнер – это легковесный, автономный и исполняемый пакет программного обеспечения, который включает в себя все зависимости (библиотеки, двоичные файлы и файлы конфигурации), необходимые для запуска приложения. Контейнеры изолируют приложения от их окружения, обеспечивая их единообразную работу в различных системах.

### Компоненты Docker

В экосистеме Docker существует три ключевых компонента:

* **Dockerfile**: текстовый файл, содержащий инструкции (команды) для создания Docker-образа.
* **Docker-образ**: слепок состояния контейнера, созданный из Dockerfile файла. Образы хранятся в реестре, например Docker Hub, и их можно извлечь или отправить в реестр.
* **Docker-контейнер**: работающий экземпляр Docker образа.

### Docker команды

Ниже приведены некоторые основные Docker команды, которые вы будете часто использовать:

* `docker pull <image>`: загрузить образ (<image>) из реестра, например Docker Hub.
* `docker build -t <image_name> <path>`: создать образ с названием (<image_name>) из Dockerfile файла, где `<path>` – это каталог, содержащий Dockerfile файл.
* `docker image ls`: вывести список всех образов, доступных на вашем локальном компьютере.
* `docker run -d -p <host_port>:<container_port> --name <container_name> <image>`: запустить контейнер, задав ему название (<container_name>), из образа (<image>), сопоставив порты хоста (<host_port>) с портами контейнера (<container_port>).
* `docker container ls`: вывести список всех запущенных контейнеров.
* `docker container stop <container>`: остановить работающий контейнер (<container>).
* `docker container rm <container>`: удалить остановленный контейнер (<container>).
* `docker image rm <image>`: удалить образ (<image>) с вашего локального компьютера.

## Сохранение данных

Docker позволяет запускать контейнеры, представляющие собой изолированные фрагменты кода, включая приложения и их зависимости, отдельно от операционной системы хоста. Контейнеры по умолчанию являются эфемерными, что означает, что любые данные, хранящиеся в контейнере, будут потеряны после завершения его работы. Чтобы решить эту проблему и сохранить данные на протяжении всего жизненного цикла контейнера, Docker предоставляет различные методы сохранения данных.

В этом разделе мы рассмотрим:

* [Docker тома (volumes)](https://github.com/MaksimDzhangirov/PHP-roadmap/edit/master/docker-roadmap.md#docker-%D1%82%D0%BE%D0%BC%D0%B0)
* [Bind Монтирование](https://github.com/MaksimDzhangirov/PHP-roadmap/edit/master/docker-roadmap.md#bind-%D0%BC%D0%BE%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
* [Docker tmpfs монтирование](https://github.com/MaksimDzhangirov/PHP-roadmap/edit/master/docker-roadmap.md#docker-tmpfs-%D0%BC%D0%BE%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

### Docker тома (volumes)

Docker тома – это предпочтительный способ сохранения данных, созданных и используемых Docker контейнером. Том – это каталог на хост-компьютере, который Docker использует для хранения файлов и каталогов, которые могут пережить жизненный цикл контейнера. Docker тома могут совместно использоваться контейнерами, и они предоставляют различные преимущества, такие как простое резервное копирование и миграция данных.

Чтобы создать том, используйте следующую команду:

```shell
docker volume create volume_name
```

Чтобы использовать том, добавьте флаг `--volume` (или `-v`) в вашу команду `docker run`:

```shell
docker run --volume volume_name:/container/path image_name
```

### Bind Монтирование

Bind монтирование позволяет сопоставить любой каталог на хост-компьютере с каталогом внутри контейнера. Этот метод может быть полезен в средах разработки, где вам необходимо изменить файлы в хост-системе, и эти изменения должны быть немедленно доступны в контейнере.

Чтобы создать bind монтирование, используйте флаг `--mount` с `type=bind` в вашу команду `docker run`:

```shell
docker run --mount type=bind,src=/host/path,dst=/container/path image_name
```

### Docker tmpfs монтирование

Docker tmpfs монтирование позволяет создать временное файловое хранилище прямо в памяти контейнера. Данные, хранящиеся в файлах tmpfs монтирования, являются быстрыми и безопасными, но будут потеряны после завершения работы контейнера.

Чтобы использовать tmpfs монтирование, добавьте флаг `--tmpfs` в вашу команду `docker run`:

```shell
docker run --tmpfs /container/path image_name
```

Используя эти методы, вы можете обеспечить сохранение данных на протяжении всего жизненного цикла контейнера, увеличивая пользу и гибкость Docker контейнеров. Не забудьте выбрать метод, который лучше всего подходит для вашего конкретного случая, будь то чаще всего рекомендуемые Docker тома, простое bind монтирование или быстрое и безопасное tmpfs монтирование.

### Эфемерная файловая система контейнера

По умолчанию хранилище внутри контейнера Docker является эфемерным, а это означает, что любые изменения или модификации данных, сделанные внутри контейнера, будут сохраняться только до тех пор, пока контейнер работает. Как только контейнер будет остановлен и удален, все связанные данные будут потеряны. Это связано с тем, что Docker контейнеры по своей природе спроектированы так, чтобы не сохранять состояние.

Это временное или кратковременное хранилище называется «эфемерной файловой системой контейнера». Это важная функция Docker, поскольку она обеспечивает быстрое и согласованное развертывание приложений в различных средах, не беспокоясь о состоянии контейнера.

#### Эфемерная файловая система и сохранение данных

Поскольку любые данные, хранящиеся в эфемерной файловой системе контейнера, теряются при остановке или удалении контейнера, это создаёт проблему для сохранения данных в приложениях. Это особенно проблематично для таких приложений, как базы данных, которым требуется сохранение данных на протяжении нескольких жизненных циклов контейнера.

Чтобы преодолеть эти проблемы, Docker предоставляет несколько методов сохранения данных, таких как:

* **Тома**: вариант хранилища, управляемый Docker, хранящийся вне файловой системы контейнера, позволяющий сохранять данные при перезапуске и удалении контейнера.
* **Bind монтирование**: отображение каталога или файла хост-машины в контейнер, позволяет эффективно совместно использовать хранилища хоста с контейнером.
* **tmpfs монтирование**: хранилище в памяти, полезно в тех случаях, когда требуется только сохранение данных в течение жизненного цикла контейнера.

Реализуя эти стратегии, Docker гарантирует, что данные приложения могут быть сохранены за пределами жизненного цикла одного контейнера, что позволяет работать с приложениями, где необходимо сохранение состояния.

### Монтирование томов

Монтирование томов – это способ сопоставить папку или файл в хост-системе с папкой или файлом внутри контейнера. Это позволяет данным сохраняться вне контейнера, даже если контейнер удален. Кроме того, несколько контейнеров могут использовать один и тот же том, что упрощает обмен данными между контейнерами.

#### Создание тома

Чтобы создать том в Docker, вам необходимо выполнить следующую команду:

```shell
docker volume create my-volume
```
Эта команда создаст том с названием `my-volume`. Вы можете просмотреть подробную информацию о созданном томе с помощью команды:

```shell
docker volume inspect my-volume
```

#### Монтирование тома в контейнер

Чтобы смонтировать том в контейнер, вам необходимо использовать флаг `-v` или `--mount` во время запуска контейнера. Например:

Используя флаг `-v`:

```shell
docker run -d -v my-volume:/data your-image
```

Используя флаг `--mount `:

```shell
docker run -d --mount source=my-volume,destination=/data your-image
```

В обоих приведенных выше примерах `my-volume` – это название тома, который мы создали ранее, а `/data` – это путь внутри контейнера, куда будет смонтирован том.

#### Совместное использование томов несколькими контейнерами

Чтобы cовместно использовать том, просто смонтируйте один и тот же том в нескольких контейнерах. Вот как можно совместно использовать `my-volume` двумя контейнерами, на которых запущены разные образы:

```shell
docker run -d -v my-volume:/data1 image1
docker run -d -v my-volume:/data2 image2
```

В этом примере `image1` и `image2` будут иметь доступ к одним и тем же данным, хранящимся в `my-volume`.

#### Удаление тома

Чтобы удалить том, вы можете использовать команду `docker volume rm`, за которой следует название тома:

```shell
docker volume rm my-volume
```

Вот и всё! Теперь у вас есть базовое представление о монтировании томов в Docker. Вы можете использовать их для эффективного и безопасного сохранения и обмена данными между вашими контейнерами.

### Bind Монтирование

Bind монтирование имеет ограниченную функциональность по сравнению с томами. При его использовании файл или каталог на хост-компьютере монтируется в контейнер. На файл или каталог ссылаются по его абсолютному пути на хост-компьютере. Напротив, когда вы используете том, в каталоге хранилища Docker на хост-компьютере создается новый каталог, и Docker управляет содержимым этого каталога.

Файл или каталог не обязательно должен уже существовать на Docker хосте. Он создается по требованию, если он еще не существует. Bind монтирование очень эффективно, но она зависит от наличия в файловой системе хост-компьютера определенной структуры каталогов.

Полезные ссылки:

* [Docker Bind Mounts](https://docs.docker.com/storage/bind-mounts/)

## Использование сторонних образов

Сторонние образы – это готовые образы контейнеров Docker, доступные в Docker Hub или других реестрах контейнеров. Эти образы создаются и поддерживаются частными лицами или организациями и могут использоваться в качестве отправной точки для ваших контейнерных приложений.

#### Поиск сторонних образов

Docker Hub – это крупнейший и самый популярный реестр образов контейнеров, содержащий как официальные образы, так и образы, поддерживаемые сообществом. Вы можете искать образы по названию или технологии, которую хотите использовать.

Например: если вы ищете образ `Node.js`, вы можете выполнить поиск по запросу «node» в Docker Hub и найти официальный образ Node.js вместе со многими другими образами, поддерживаемыми сообществом.

#### Использование образа в вашем Dockerfile

Чтобы использовать сторонний образ в своем Dockerfile, просто задайте название образа в качестве базового с помощью директивы `FROM`. Вот пример использования официального образа Node.js:

```
FROM node:14

# Остальная часть вашего Dockerfile...
```

#### Помните о проблемах, связанных с безопасностью

Имейте в виду, что сторонние образы потенциально могут иметь уязвимости, свяазнные с безопасностью или неправильные настройки. Всегда проверяйте источник образа и его репутацию, прежде чем использовать его на продакшене. Предпочитайте использовать официальные образы или образы, поддерживаемые сообществом.

#### Поддержка ваших образов

При использовании сторонних образов важно постоянно обновлять их, чтобы внедрять последние обновления безопасности и изменения зависимостей. Регулярно проверяйте наличие обновлений в базовых образах и исходя из этого пересобирайте контейнеры приложений.

### Базы данных

Запуск вашей базы данных в Docker контейнере может помочь оптимизировать процесс разработки и упростить развертывание. Docker Hub предоставляет множество готовых образов для популярных баз данных, таких как MySQL, PostgreSQL и MongoDB.

#### Пример: использование образа MySQL

Чтобы использовать базу данных MySQL, поищите официальный образ в Docker Hub:

```
docker search mysql
```

Найдите официальный образ и извлеките его:

```
docker pull mysql
```

Теперь вы можете запустить MySQL контейнер. Укажите необходимые переменные окружения, такие как `MYSQL_ROOT_PASSWORD`, и при необходимости сопоставьте порт контейнера с вашим хост-компьютером:

```
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -p 3306:3306 -d mysql
```

Эта команда создает новый контейнер с именем `some-mysql`, устанавливает пароль для `root` пользователя равным `my-secret-pw` и сопоставляет порт 3306 на хосте с портом 3306 в контейнере.

#### Пример: использование образа PostgreSQL

Для PostgreSQL выполните действия, аналогичные описанным выше. Сначала найдите официальный образ:

```
docker search postgres
```

Извлеките образ:

```
docker pull postgres
```

Запустите PostgreSQL контейнер, указав переменные окружения, такие как `POSTGRES_PASSWORD`:

```
docker run --name some-postgres -e POSTGRES_PASSWORD=my-secret-pw -p 5432:5432 -d postgres
```

Запуск MongoDB контейнера с помощью Docker происходит по той же схеме, которая использовалась для вышеприведенных примеров. Найдите официальный образ:

```
docker search mongo
```

Извлеките образ:

```
docker pull mongo
```

Запустите MongoDB контейнер:

```
docker run --name some-mongo -p 27017:27017 -d mongo
```

### Интерактивные тестовые среды
### Утилиты командной строки

## Создание образов контейнеров

### Dockerfile
### Эффективное кэширование слоев
### Размер образа и настройки безопасности

## Реестры контейнеров
### DockerHub
### Альтернативы DockerHub (ghcr, ecr, gcr, act и т. д.)
### Рекомендации по добавлению тегов к образу

## Запуск контейнеров

### docker run
### docker Compose
### Настройка параметров в момент запуска

## Настройка безопасности контейнера

### Меры безопасности для защиты образа
### Меры безопасности во время выполнения

## Docker CLI

### Образы
### Контейнеры
### Тома
### Сети

## Простота и скорость разработки

### Перезагрузка налету
### Отладчики
### Тесты
### Непрерывная интеграция

## Развертывание контейнеров
### PaaS альтернативы
### Kubernetes
### Docker Swarm
### Nomad

Продолжайте обучение, используя одну из следующих карт, связанных с этой:

[Дорожная карта Backend-разработчика](https://roadmap.sh/backend)

[Дорожная карта DevOps](https://roadmap.sh/devops)



